# Problem

- [문제 링크](https://programmers.co.kr/learn/courses/30/lessons/64061)

<br>

2 x 2 배열의 보드판이 주어집니다.

인형을 뽑는 위치를 정하는 `moves` 배열이 정해집니다.

위치는 가로만 정해지며, 해당 위치의 가장 위에 있는 인형만 뽑을 수 있습니다.

뽑은 인형은 바구니에 순서대로 쌓이며, 같은 인형이 연달아 들어온 경우 두 인형은 사라집니다.

사라진 인형의 갯수를 구해야 합니다.

<br><br>

# Solution

단순한 구현 문제입니다.

`int[] getHeights(int[][] board)` 함수로 모든 위치에서의 인형 높이를 구해둡니다.

`moves` 를 순회하며 인형 뽑기, 바구니에 넣기, 사라지게 하기를 순서대로 구현합니다.

바구니는 `Stack` 으로 관리하면 됩니다.

인형을 뽑은 후에는 미리 구해둔 `heights` 배열의 값을 하나 증가시켜줍니다.

이러면 매번 높이를 구하는 O(n) 작업을 생략할 수 있습니다.

<br><br>

# Java Code

```java
import java.util.*;

class Solution {
    public int solution(int[][] board, int[] moves) {
        int[] heights = getHeights(board);
        Stack<Integer> stack = new Stack<>();
        int count = 0;

        for (int move : moves) {
            if (heights[move - 1] == board.length) continue;

            int row = move - 1;
            int col = heights[row];
            int doll = board[col][row];

            if (!stack.isEmpty() && stack.peek() == doll) {
                stack.pop();
                count++;
            } else {
                stack.push(doll);
            }

            heights[row]++;
            board[col][row] = 0;
        }

        return count * 2;
    }

    private int[] getHeights(int[][] board) {
        int[] ret = new int[board[0].length];

        for (int i = 0; i < board[0].length; i++) {
            for (int j = 0; j < board.length; j++) {
                if (board[j][i] != 0) {
                    ret[i] = j;
                    break;
                }
            }
        }

        return ret;
    }
}
```
